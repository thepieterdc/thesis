% !TeX root = ../thesis.tex

\section{Pipeline}
This section will elaborate on the individual steps of the pipeline. The steps will be discussed by manually executing the pipeline that has hypothetically been implemented on a Java project. For the sake of simplicity, this explanation will assume a steady-state situation, ensuring the existence of at least one completed run of this project in the database at the controller side.

\subsection{Initialisation}
As was explained before, the provided Java implementation of the agent was designed to be used in conjunction with Gradle. In order to integrate \velocity{} into a Gradle project, the build script (\texttt{build.gradle}) should be modified in two places. The first change is to include and apply the plugin in the header of the file. Afterwards, the plugin requires three properties to be configured:
\begin{itemize}
	\item \texttt{base} the path to the Java source files, relative to the location of the build script. This will typically resemble \texttt{src/main/java}.
	
	\item \texttt{repository} the url to the git repository at which the project is hosted. This is required in subsequent steps of the pipeline, to detect which code lines have been changed in the commit currently being analysed.
	
	\item \texttt{server} the url at which the controller can be reached.
\end{itemize}

\noindent \autoref{lst:pipeline-buildgradle} contains a minimal integration of the agent in a Gradle build script, applied to a library for generating random numbers\footnote{\url{https://github.com/thepieterdc/random-java}}}. The controller is hosted at the same host as the agent and is accessible at port \texttt{8080}.

\lstinputlisting[caption=Minimal Gradle buildscript, label=lst:pipeline-buildgradle, language=Groovy]{assets/listings/build.gradle}

- started door commit hash mee te geven (doorzoek history ofzo)

- create run at controller
- storage in database

\subsection{Prediction}
- bespreek predictor daemon
- bespreek de 10 algoritmes
- bespreek de metapredictor

\subsection{Test case execution}
- executor

\subsection{Post analysis}
- bereken duration
- bereken coverage
- update metapredictor

% for interpreting the changed 

%This chapter will start by providing a high-level overview of the implemented architecture, followed by 

%to optimise the test suite, as well as provide useful insights. The framework was named \emph{VeloCIty} to reflect its purpose of enhancing the speed of \CI{} systems. This chapter will start by 




%(TODO)

%- Implementatiedetails van algoritmes

%- Uitwerking: nog onder voorbehoud (2e semester)

%- Metapredictor: Voer alle algoritmes eens uit en rangschik ze volgens hoe goed ze het voorspeld hebben

%- Scoringsmechanisme: Nog bepalen

%- Junit: https://www.baeldung.com/junit-5-test-order

%\subsection{Architectuur}
%- Commit
%- POST /commit
%data: parent commit hash, huidige commit hash
%result: volgorde van tests
%- voer tests uit in gegeven volgorde
%- POST /result
%data: huidige commit hash, gefaalde tests

%\subsection{Junit-reorder}
%- Orde vastleggen in yaml files (plaats voorbeeld)
%- Out of the box support om tests binnen eenzelfde klasse in volgorde uit te voeren, maar niet class-wide support
%- Na elke uitvoering van een test wordt een nieuwe processor aangemaakt met een filter op de methodnaam, dit heeft als nadeel dat hergebruiken van initialisaties niet gaat. Misschien hier nog iets op vinden
%- Parallelliseren momenteel niet gesupport, geen idee hoe dat zou werken met een volgorde (kan niet gewoon verdelen in volgorde want stel dat 1 test heel lang duurt dan is die volgorde niet meer juist)
%- Shortcuts genomen wegens problemen met gradle (shaded jars) -> bepaalde JUnit functionaliteit weggegooid (vooral @Ignored annotatie)

%Na elke uitvoering van test wordt coverage data bijgehouden om later te analyseren door test processor hack (maak hier zo'n mooi ding van).

%Coverage data formaat optimaliseren zodat xmlfile niet gigantisch groot wordt -> done

%Algoritmes aanpassen zodat branches ook rekening mee gehouden wordt (stel dat test A lijn 5 covert en test B ook, maar lijn 5 is een if-statement met 2 condities en test A triggert enkel de eerste conditie, dan zal test B met lagere prioriteit worden uitgevoerd of zelfs niet omdat de lijn al gecoverd is) -> eventueel via mutator die branches naar lijnen uitsplitst in zowel tests als source

%Andere programmeertalen kunnen op zelfde manier door tests sequentieel uit te voeren

%<https://rubygems.org/gems/reverse_coverage/