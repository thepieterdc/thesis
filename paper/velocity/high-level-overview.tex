% !TeX root = ../thesis.tex

\section{Architecture}
The architecture of \velocity{} consists of seven steps that are performed sequentially in a pipeline fashion, as illustrated in \autoref{fig:velocity-pipeline}. Every step is executed by one of three individual components, which will now be introduced briefly.

\begin{figure}[htbp!]
	\centering
	\includegraphics[width=\textwidth]{assets/pipeline.pdf}
	\caption{Architectural overview of \velocity{}}
	\label{fig:velocity-pipeline}
\end{figure}

\subsection{Frontend}\label{ssec:velocity-frontend}
The first component is the frontend of the framework. This is the only component that depends actively on both the programming language, as well as the used test framework, since it must interact directly with the source code and test suite. For every programming language or test framework that needs to be supported, a different frontend must be implemented. This implementations are however strongly related, so much code can be reused or even shared. In this thesis, the frontend was created in Java and implemented as a plugin for the widely used Gradle and JUnit test framework. This combination was previously described in \autoref{ssec:relatedwork-gradle-junit}. This plugin is responsible for running the test suite in a certain prioritised order, which is obtained by communicating with the backend (\autoref{ssec:velocity-backend}). After the test cases have been executed, the plugin sends a feedback report to the backend, where it is analysed.

\subsection{Backend}\label{ssec:velocity-backend}
The second component is the core of the framework, acting as an intermediary between the frontend on the left side and the predictor (\autoref{ssec:velocity-predictor}) on the right side. In order to satisfy the second design goal and allow language agnosticism, the frontend communicates with the backend using the \texttt{HTTP} protocol by exposing a \emph{REST}-interface. Representational State Transfer \texttt{[REST]} is a software architecture used by modern web applications that allows standardised communication using existing HTTP methods. On the right side, the backend does not communicate directly with the predictor, but rather stores prediction requests in a shared database which is periodically polled by the predictor. Besides routing prediction requests from the frontend to the predictor, the backend component will also update the meta-predictor by evaluating the accuracy of earlier predictions of this project.

\subsection{Predictor and Metrics}\label{ssec:velocity-predictor}
The final component is twofold. Its main responsibility is to apply the prioritisation algorithms and predict an order in which the test cases should be executed. This order is calculated by first executing ten algorithms and subsequently picking the algorithm that has been preferred by the meta-predictor. Additionally, this component is able to provide metrics about the test suite, such as identifying superfluous test cases by applying \tsm{}. More specifically, this redundancy is obtained using the greedy algorithm (\autoref{ssec:alg-greedy}). Both of these scripts have been implemented in Python, because of its simplicity and existing libraries for many common operations, such as numerical calculations (NumPy\footnote{\url{https://numpy.org/}}) and machine learning (TensorFlow\footnote{\url{https://www.tensorflow.org/}}).