% !TeX root = thesis.tex

\chapter{Related work}
In the previous chapter I have stressed the paramount importance of periodically integrating one's changes into the upstream repository. Additionally, Continuous Integration was introduced as both a practice and a tool to facilitate this often complex and time-consuming process. However, Continuous Integration is not the golden bullet for software engineering. In this chapter I will investigate the flip side of applying this practice. After every integration, all of the unit and regression tests in the test suite must be executed to ensure that the integration was successful and that no new bugs have been introduced. As the project evolves, the size of the codebase increases and consequently the amount of tests will increase as well in order to maintain a sufficiently high coverage level. An increase in the size of the test suite will inevitably lead to an increase in test duration \cite{evaluationoftestsuiteminimization}, which imposes an issue of scaling. Walcott, Soffa and Kapfhammer illustrate the magnitude of this problem by providing an example of a codebase consisting of 20.000 lines, for which the tests require up to seven weeks to complete \cite{10.1145/1146238.1146240}.\\

\noindent Fortunately, multiple developers and researchers have found some techniques that can be used to address the scalability issues of growing test suites. The techniques currently known to literature can be classified in three categories. Developers can either apply \emph{\tsm{}}, \emph{\tcs{}} or \emph{\tcp{}} \cite{evaluationoftestsuiteminimization}. All three techniques are applicable to any test suite, however there is a trade-off to be made. Depending on which technique is chosen, it will either have a major impact on the duration of the test suite execution in exchange for a reduced test coverage level, or it will result in a higher test adequacy.\\

\noindent In the following sections I will first elaborate on the details of these three approaches, then I will provide accompanying algorithms that can be used. Since the approaches share common ideas, the algorithms can (albeit with minor modifications) be reused across all approaches. In the final section I will illustrate some examples of the discussed techniques and algorithms that are currently integrated in existing software testing frameworks.

\input{related-work/approaches.tex}
\input{related-work/algorithms.tex}

\section{Existing implementations}
- OpenClover (enkel Java) heeft hier misschien support voor