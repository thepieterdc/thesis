% !TeX root = ../../thesis.tex

\subsection{\CI}
In traditional software development, the design phase usually leads to a representation of the required functionality in multiple, stand-alone modules. These modules are then implemented separately by the individual developers and are afterwards integrated into one monolithic application. This operation can prove to be very complicated since every developer can make their assumptions at the start of the project. Ultimately, these assumptions may render the components mutually incompatible. Furthermore, since it can take several weeks to months before this integration takes place, the developers often need to rewrite old code. Eventually, this will lead to unanticipated delays and costs \cite{SmartJenkinsDefinitive}.\\

\noindent Contrarily, agile development methodologies advocate the idea of frequent, yet small deliverables. In order to obtain frequent deliverables, we require to build the code often and integrate the modules multiple times, \emph{continuously}, rather than just once at the end. Another advantage of frequent deliverables is the early identification of problems \cite{gitlabci}. We refer to this practice as \acrfull{ci} \cite{SmartJenkinsDefinitive}. Note that this idea has existed before the creation of the Agile manifesto. The first notorious software company that has adopted CI is Microsoft in 1989 \cite{cusumanomicrosoft}. Cusumano reports that Microsoft typically builds the entire application at least once per day and as such requires developers to integrate and test their changes multiple times per day.\\

\noindent The introduction of \CI{} in software development has significant consequences on the life cycle. Where the waterfall model used a cascading life cycle, CI employs a circular, repetitive structure consisting of three phases, as visualised in \Cref{fig:agile-ci-lifecycle}.

\begin{enumerate}
	\bolditem{Implementation} In the first phase, every developer writes code individually for their assigned module. At a regular interval, the code is committed to the remote repository.
	
	\bolditem{Integration} When the developer commits their changes, they simultaneously fetch the changes other developers have made to their modules. Afterwards, the developer must integrate these remote changes with their local module to ensure these remain compatible. In case of a conflict, the developer is responsible for resolving this locally \cite{martin2014}.
	
	\bolditem{Test} After the developer has successfully integrated the remote modules to the locale module, the test suite must be executed to verify that no regressions have been introduced.
\end{enumerate}

\begin{figure}[htbp!]
	\centering
	\includegraphics[width=0.45\textwidth]{assets/images/ci-lifecycle.pdf}
	\caption{Development Life Cycle with \CI{}.}
	\label{fig:agile-ci-lifecycle}
\end{figure}

\noindent Adopting \CI{} can prove to be a lengthy and repetitive task. Luckily, a variety of tools and frameworks exist to automate this process. These tools are typically attached to a version control system (e.g. Git, Mercurial, \dots) using a \texttt{post-receive} hook \cite{SmartJenkinsDefinitive}. Every time the developers push a commit to the repository, the hook will notify the CI system. The CI system will respond accordingly by automatically building the code and executing the test cases. Optionally, we can configure the CI system to automatically publish successful builds to the end-users, a process referred to as \emph{Continuous Delivery}. This paper will now proceed by discussing four prominent CI systems.

\input{software-engineering/agile-software-development/continuous-integration/jenkins.tex}
\input{software-engineering/agile-software-development/continuous-integration/github-actions.tex}
\input{software-engineering/agile-software-development/continuous-integration/gitlab-ci.tex}
\input{software-engineering/agile-software-development/continuous-integration/travis-ci.tex}