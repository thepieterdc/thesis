% !TeX root = ../../thesis.tex

\subsection{Continuous Integration}
In traditional software development, the design phase typically leads to a representation of the required functionality in multiple, stand-alone modules. Subsequently, every module is implemented separately by individual developers. Afterwards, an attempt is made to integrate all the modules into the final application, an event to which Meyer refers to as the ``Big Bang'' \cite[~p.103]{Meyer2014}. The name \emph{Big Bang} reflects the complex nature of this operation, since every developer can take unexpected assumptions, resulting in mutually incompatible components.\\

\noindent Contrarily, agile development methodologies advocate the idea of frequent, yet small deliveries (\autoref{sssec:agilevalue-workingsoftware}). Consequently, this implies that the code is built often and that the modules are integrated multiple times, on a \emph{continuous} basis, rather than just once at the end. This practice of frequent builds is referred to as \emph{Continuous Integration} \cite{martin2014,Meyer2014}. It should be noted that this idea exists and has been applied before the agile manifesto was written. The first notorious software company that has adopted this practice is Microsoft, already in 1989 \cite[~p.11]{cusumanomicrosoft}. Cusumano reports that Microsoft typically builds the entire application at least once per day \cite[~p.12]{cusumanomicrosoft}, which in turn requires developers to integrate and test their changes multiple times per day.\\

\noindent The introduction of Continuous Integration in software development has important consequences on the life cycle. Where the waterfall model used a cascading life cycle, Continuous Integration employs a circular, repetitive structure consisting of three phases, as visualised in \autoref{fig:agile-ci-lifecycle}.

% zie een van die papers

\begin{enumerate}
	\bolditem{Implementation} In the first phase, every developer individually writes code for the module they were assigned to. At a regular interval, the code is committed to the remote repository.
	
	\bolditem{Integration} When the code is committed, the developer simultaneously fetches the changes to other modules. Afterwards, the developer must integrate the changes with his own module, to ensure compatibility. In case a conflict occurs, the developer is responsible for its resolution \cite{martin2014}.
	
	\bolditem{Test} After the module has successfully been integrated, the test suite is run to ensure no bugs have been introduced.
\end{enumerate}

\begin{figure}[htbp!]
	\centering
	\includegraphics[width=0.5\textwidth]{assets/ci-lifecycle.pdf}
	\caption{Development Life Cycle with Continuous Integration}
	\label{fig:agile-ci-lifecycle}
\end{figure}

\noindent Adopting Continuous Integration can prove to be a lengthy and repetitive task. Luckily, a variety of tools and frameworks exist to automate this process. These tools are typically added as a \texttt{post-receive} hook to the version control system (e.g. Git, Subversion, \dots). Every time a commit is pushed by a developer, the code is built and tests are executed. I will now discuss four prominent Continuous Integration systems.

\subsubsection{Jenkins}
// TODO EXPLAIN

\subsubsection{CircleCI}
// TODO EXPLAIN

\subsubsection{Travis-CI}
// TODO EXPLAIN

\subsubsection{GitHub Actions}
// TODO EXPLAIN