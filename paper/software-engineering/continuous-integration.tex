\section{Continuous Integration}
\subsection{Agile Manifesto}
Since the late 1990's, developers have tried to reduce the time occupied by the implementation and testing phases. In order to accomplish this, several new implementations of the SDLC were proposed and evaluated, later collectively referred to as \emph{Agile development methodologies}. The term \emph{Agile development} was coined during a meeting of seventeen prominent software developers, held between February 11-13, 2001, in Snowbird, Utah \cite{jimhighsmith2001}. As a result of this meeting, the developers defined the four key values and twelve principles that define these new methodologies, called the \emph{Manifesto for Agile Software Development}, also known as the \emph{Agile Manifesto}.\\

\noindent The four key values of Agile software development should be interpreted as follows, according to the authors: "While there is value in the items on the right, we value the items on the left more" \cite{beck2001agile}. I will explain these key values and their corresponding principles, as proposed by Kiv \cite[p.~12]{10.1007/978-3-030-03673-7_2}. It should be noted that these values are merely guidelines and that no concrete implementation is provided. A variety of different programming models, based on the agile ideologies, have arisen since 2001, each incorporating these values and principles in their own unique way.

\subsubsection{\emph{Individuals and interactions} over processes and tools}
Instead of meticulously following an outlined development process and utilising the best tools available, the main focus of attention should shift to the people behind the development and how they are interacting with each other. According to Glass, the quality of the programmers and the team is the most influential factor in the successful development of software \cite{glass2001agile}. 

\agileprinciple{5}{Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.}
TODO EXPLAIN

\agileprinciple{6}{The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.}
TODO EXPLAIN

\agileprinciple{8}{Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.}
TODO EXPLAIN

\agileprinciple{11}{The best architectures, requirements, and designs emerge from self-organizing teams.}
TODO EXPLAIN

\agileprinciple{12}{At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.}
TODO EXPLAIN

\subsubsection{\emph{Working software} over comprehensive documentation}
The primary goal of software engineering is to deliver a working end product which fulfils the needs of the customer. In order to accomplish this, development should start as soon as possible. Traditional programming models demand a lot of documentation to be written prior to the actual development, which will inevitably lead to inconsistencies between the documentation and the actual application as the project grows and the requirements change \cite{Hazzan2014}. 
	
\agileprinciple{1}{Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.}
TODO EXPLAIN

\agileprinciple{3}{Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.}
TODO EXPLAIN

\agileprinciple{7}{Working software is the primary measure of progress.}
TODO EXPLAIN

\agileprinciple{10}{Simplicity--the art of maximizing the amount of work not done--is essential.}
TODO EXPLAIN

\subsubsection{\emph{Customer collaboration} over contract negotiation}
In traditional software engineering, the role of the customer is subordinate to the developer. Agile software engineering maintains a different perception of this role, treating both the customer and developers as equal entities. Daily contact between both parties is of vital importance to avoid misunderstandings and a short feedback loop allows the developers to cope with changes in requirements and to ensure that the customer is satisfied with the delivered product \cite{Hazzan2014}.

\agileprinciple{4}{Business people and developers must work together daily throughout the project.}
TODO EXPLAIN

\subsubsection{\emph{Responding to change} over following a plan}
The first step of the aforementioned waterfall model (\autoref{sec:se-sdlc}) was to ensure both the customer and the developers have a complete and exhaustive view of the entire application. In reality however, this has proven to be rather difficult and sometimes even impossible. As a result of this, a change in requirements was one of the most common causes of software project failure \cite{glass2001agile}. Consequently, the agile software development methodologies do not require a complete specification of the final product to be known a priori and stimulate the developers to successfully cope with changes as the application is being developed \cite{Hazzan2014}. This is accomplished by working in short iterations (sprints), instead of programming the entire application at once, which is the case with the traditional programming models.

\agileprinciple{2}{Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.}
TODO EXPLAIN

\agileprinciple{9}{Continuous attention to technical excellence and good design enhances agility.}
TODO EXPLAIN

\subsection{The need for Agile}
Over the past decade, the agile methodologies have received increasing attention amongst software developers, following the world economic crisis of 2009 \cite{ionel2009}. A consequence of this crisis was that software companies were forced to cut on their expenses and find ways to reduce the \emph{time-to-market} of their applications.

- probleem met waterfall model -> een bron hiervoor?

- feedback loop

- buildup naar waarom tooling nodig is

- waarom

- wat

- voorbeelden: Jenkins, CircleCI, Travis-CI, recent GitHub Actions + screenshots

- Probleem en oplossingen met regression tests

  - Test Case Prioritization -> Focus want geen tests weggooien
  
  - Test Suite Minimization
  
  - Test Suite Selection
  
  - Test Suite Reduction
